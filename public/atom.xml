<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>todo(): redo · Mikhail Bakulin&#39;s blog</title>
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2017-04-11T07:34:01.815Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>Mikhail Bakulin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Import XML file into database</title>
    <link href="http://localhost:4000/2017/01/08/import-xml-into-sql/"/>
    <id>http://localhost:4000/2017/01/08/import-xml-into-sql/</id>
    <published>2017-01-07T21:00:00.000Z</published>
    <updated>2017-04-11T07:34:01.815Z</updated>
    
    <content type="html"><![CDATA[<p>I will not talk about whether it’s a good idea or not to store dump in XML, let’s suppose you have this huge XML file and you need to load it in your database. In fact the bigger the file is the more problem you have because you need to think about import performance and memory consumption. Also, the schema of the data inside your dump may be messy or totally irrational. All this determines the required flexibility of your import method.</p>
<p>For the sake of this article, I will use <a href="https://archive.org/download/stackexchange" target="_blank" rel="external">stackoverflow comments dump</a> which is nearly 10Gb after unpacking.<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> comments (</div><div class="line">  <span class="string">"Id"</span> <span class="built_in">serial</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">  <span class="string">"PostId"</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">"Score"</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">"Text"</span> <span class="built_in">TEXT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">"CreationDate"</span> <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">"UserId"</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="literal">NULL</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>That’s would a table for our comments dataset. Column names taken from xml node attributes.</p>
<h3 id="Native-import-in-MySQL"><a href="#Native-import-in-MySQL" class="headerlink" title="Native import in MySQL"></a>Native import in MySQL</h3><p>To demonstrate how easy this stuff can be, let’s look at how MySQL handles that kind of task:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">LOAD</span> <span class="keyword">XML</span> <span class="keyword">LOCAL</span> <span class="keyword">INFILE</span> <span class="string">'/var/lib/mysql/dump/Comments.xml'</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> comments <span class="keyword">ROWS</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'&lt;row&gt;'</span>;</div></pre></td></tr></table></figure></p>
<p>The Mysql solution is short and simple, but it works only on version &gt;=5.5.  Column names associated with either node attributes or <code>field</code> nodes with required <code>name</code> attribute. In the last case value for the particular column will be taken from node text. If you are interested you can find more about it in <a href="https://dev.mysql.com/doc/refman/5.5/en/load-xml.html" target="_blank" rel="external">official Mysql docs</a>.</p>
<p>Import took just about 2 hours for our test XML dump.</p>
<p>Simplicity in MySQL came with a price, as it’s kind of limited in allowed XML formatting. That’s can be a huge problem for example if you import relational data.</p>
<h3 id="XML-processing-functions-in-PostgreSQL"><a href="#XML-processing-functions-in-PostgreSQL" class="headerlink" title="XML processing functions in PostgreSQL"></a>XML processing functions in PostgreSQL</h3><p>I decided to put MySQL example here for a reason. Not that MySQL lacks XML processing, it’s PostgreSQL that don’t have such a simple solution. Postgres have advanced functionality and that usually leads to overcomplicated solutions. When I was searching for a way to do XML import I stumbled upon <a href="http://stackoverflow.com/a/7628453" target="_blank" rel="external">this stackoverflow answer</a> which give me a hint on how to solve my problem but introduced a lot of custom user functions, which wasn’t necessary. I ended up with this:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> comments</div><div class="line">  <span class="keyword">SELECT</span> (xpath(<span class="string">'//row/@Id'</span>, x))[<span class="number">1</span>]::<span class="built_in">text</span>::<span class="built_in">int</span> <span class="keyword">AS</span> <span class="keyword">Id</span>,</div><div class="line">         (xpath(<span class="string">'//row/@PostId'</span>, x))[<span class="number">1</span>]::<span class="built_in">text</span>::<span class="built_in">int</span> <span class="keyword">AS</span> PostId,</div><div class="line">         (xpath(<span class="string">'//row/@Score'</span>, x))[<span class="number">1</span>]::<span class="built_in">text</span>::<span class="built_in">int</span> <span class="keyword">AS</span> Score,</div><div class="line">         (xpath(<span class="string">'//row/@Text'</span>, x))[<span class="number">1</span>]::<span class="built_in">text</span> <span class="keyword">AS</span> <span class="built_in">Text</span>,</div><div class="line">         (xpath(<span class="string">'//row/@CreationDate'</span>, x))[<span class="number">1</span>]::<span class="built_in">text</span>::<span class="built_in">date</span> <span class="keyword">AS</span> CreationDate,</div><div class="line">         (xpath(<span class="string">'//row/@UserId'</span>, x))[<span class="number">1</span>]::<span class="built_in">text</span>::<span class="built_in">int</span> <span class="keyword">AS</span> UserId</div><div class="line">  <span class="keyword">FROM</span> unnest(xpath(<span class="string">'//row'</span>, pg_read_file(<span class="string">'dump/Comments.xml'</span>)::<span class="keyword">xml</span>)) x;</div></pre></td></tr></table></figure></p>
<p>XPath provide a lot of flexibility, this time we are not limited with specific XML format. This method have some non-obvious quirks though:</p>
<ul>
<li>Your dump should be in the data directory of Postgres. That’s the pg_read_file function requirement. There are some alternatives to it in Postgres, more on that matter in stackoverflow thread mentioned above.</li>
<li>As you can see XML field type can’t be directly converted to integer. You need a intermediate conversion to text.</li>
<li>Your dump shoudn’t have BOM. You should <a href="http://www.linuxask.com/questions/how-to-remove-bom-from-utf-8" target="_blank" rel="external">remove it</a> before running import otherwise you’ll receive an error.</li>
</ul>
<p>And the most important one: it fails on large XML files: <code>ERROR:  requested length too large</code>. So we either need to split our file on smaller pieces or use different approach.</p>
<h3 id="Import-using-Python"><a href="#Import-using-Python" class="headerlink" title="Import using Python"></a>Import using Python</h3><p>The key in succeeding controlling the whole process is to write your own external script. Obviously, you can’t beat above solutions in execution time, but you definitely can reduce memory consumption. </p>
<p>I used Python 3, lxml module to process dump and psycopg2 for the database connection. With my naive approach at first I got really slow performance, some major improvements were needed. To save you time I will post my final solution and then point out the most important parts:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</div><div class="line"><span class="keyword">import</span> psycopg2</div><div class="line"><span class="keyword">from</span> psycopg2.extras <span class="keyword">import</span> execute_values</div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> psutil</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sizeof_fmt</span><span class="params">(num, suffix=<span class="string">'B'</span>)</span>:</span></div><div class="line">    <span class="keyword">for</span> unit <span class="keyword">in</span> [<span class="string">''</span>,<span class="string">'Ki'</span>,<span class="string">'Mi'</span>,<span class="string">'Gi'</span>,<span class="string">'Ti'</span>,<span class="string">'Pi'</span>,<span class="string">'Ei'</span>,<span class="string">'Zi'</span>]:</div><div class="line">        <span class="keyword">if</span> abs(num) &lt; <span class="number">1024.0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"%3.1f%s%s"</span> % (num, unit, suffix)</div><div class="line">        num /= <span class="number">1024.0</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"%.1f%s%s"</span> % (num, <span class="string">'Yi'</span>, suffix)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_xml</span><span class="params">(filename, connect, insert_command, batch = [], batch_size = <span class="number">1000</span>)</span>:</span></div><div class="line">    count = <span class="number">0</span></div><div class="line">    cursor = connect.cursor()</div><div class="line">    process = psutil.Process(os.getpid())</div><div class="line">    <span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(filename, events=(<span class="string">'end'</span>,), tag=<span class="string">'row'</span>):</div><div class="line">        count += <span class="number">1</span></div><div class="line">        row = [element.get(n) <span class="keyword">for</span> n <span class="keyword">in</span> (<span class="string">'PostId'</span>, <span class="string">'Score'</span>, <span class="string">'Text'</span>, <span class="string">'CreationDate'</span>, <span class="string">'UserId'</span>)]</div><div class="line">        batch.append(row)</div><div class="line">        <span class="comment"># Free memory</span></div><div class="line">        element.clear()</div><div class="line">        <span class="keyword">if</span> element.getprevious() <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">del</span>(element.getparent()[<span class="number">0</span>])</div><div class="line">        <span class="comment"># Save batch to DB</span></div><div class="line">        <span class="keyword">if</span> count % batch_size == <span class="number">0</span>:</div><div class="line">            execute_values(cursor, insert_command, batch)</div><div class="line">            print(<span class="string">"\033[?25lImported rows: &#123;&#125; | Memory usage: &#123;&#125;\r"</span>.format(count, sizeof_fmt(process.memory_info().rss)), sep=<span class="string">''</span>, end=<span class="string">''</span>, flush=<span class="keyword">True</span>)</div><div class="line">            batch = []</div><div class="line">    <span class="comment"># Save the rest</span></div><div class="line">    <span class="keyword">if</span> len(batch):</div><div class="line">        execute_values(cursor, insert_command, batch)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">import_dump</span><span class="params">(db_name = <span class="string">'fts'</span>, db_host = <span class="string">'postgres-db'</span>, db_user = <span class="string">'postgres'</span>, db_pass = <span class="string">''</span>, db_table = <span class="string">'comments'</span>)</span>:</span></div><div class="line">    filename = <span class="string">'/dump/Comments.xml'</span></div><div class="line">    start_date = datetime.datetime.now()</div><div class="line">    <span class="keyword">print</span> (<span class="string">"Import data from &#123;&#125;"</span>.format(filename))</div><div class="line">    connect = psycopg2.connect(database=db_name, user=db_user, host=db_host, password=db_pass)</div><div class="line">    connect.autocommit = <span class="keyword">True</span></div><div class="line">    cursor = connect.cursor()</div><div class="line"></div><div class="line">    insert_command = <span class="string">'INSERT INTO &#123;&#125; (PostId, Score, Text, CreationDate, UserId) VALUES %s'</span>.format(db_table)</div><div class="line">    import_xml(filename, connect, insert_command)</div><div class="line">    connect.close()</div><div class="line"></div><div class="line">    end_date = datetime.datetime.now()</div><div class="line">    seconds = (end_date - start_date).total_seconds()</div><div class="line">    <span class="keyword">print</span> (<span class="string">"\nExecuted in &#123;&#125;s"</span>.format(seconds))</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    import_dump()</div></pre></td></tr></table></figure></p>
<ul>
<li><code>etree.iterparse</code> returns iterator providing (event, element) pairs. In contrast with <code>etree.parse</code> iterator provide a way to save memory, you just need to remove previously parsed nodes which you don’t need anymore.</li>
<li>Batch insert is much faster than separate insert for each record. You can tweak <code>batch_size</code> property in order to locate a sweet spot in performance.</li>
<li>psutil module is not required, it’s just to visualize script memory consumption.</li>
</ul>
<p>All in all, it took – minutes to import 10Gb of stackoverflow comments and used 25Mb of RAM only.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I will not talk about whether it’s a good idea or not to store dump in XML, let’s suppose you have this huge XML file and you need to loa
    
    </summary>
    
    
      <category term="PostgreSQL" scheme="http://localhost:4000/tags/PostgreSQL/"/>
    
      <category term="XML import" scheme="http://localhost:4000/tags/XML-import/"/>
    
      <category term="Python" scheme="http://localhost:4000/tags/Python/"/>
    
      <category term="SQL" scheme="http://localhost:4000/tags/SQL/"/>
    
      <category term="MySQL" scheme="http://localhost:4000/tags/MySQL/"/>
    
  </entry>
  
</feed>
